<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">

<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Evolve</title>
  <style type="text/css">
      body                    { font-family:Helvetica,Arial,sans-serif; font-size:.83em; background-color: #ccc; color:#fff; width:100%; margin:0; }

      #simulation { display: none; }
      #startup .name {
        width: 420px;
        margin: 100px auto 20px;
        font-family: Helvetica,Arial,serif;
        font-size: 18px;
        color: white;
        font-weight: bold;
        text-shadow: 0 0 4px #666;
      }
      #simulation_name {
        border: none;
        padding: 4px 6px;
        width: 180px;
        border-radius: 3px;
        font-family: Helvetica,Arial,sans-serif;
        color: #666;
        vertical-align: middle;
        box-shadow: 0 0 4px #999;
      }
      #continue {
        -webkit-appearance: none;
        border: none;
        border-radius: 4px;
        padding: 3px 8px;
        background: white;
        box-shadow: 1px 1px 2px #999;
        font-family: Helvetica,Arial,sans-serif;
        font-size: 13px;
        color: #777;
        cursor: pointer;
      }
      #continue:hover {
        box-shadow: 1px 1px 2px #000;
      }
      #continue:active {
        box-shadow: 0 0 2px #000;
      }

      #header                 { padding-left: 30px; }
      #header span            { display:inline-block; width: 40px; text-align: center; }
      #drop:hover             { cursor:pointer; }
      #display                { display: block; width:800px; margin: 20px auto 0; }
      .round { 
        clear:left; padding-left: 40px; width: 1024px; margin: 20px auto; position: relative;
        min-height: 75px; text-align: center;
      }
      #generation {
        display: block;
        margin: 15px auto 0;
        padding: 0;
        width: 800px;
        padding:0;
        font-family: 'Helvetica';
        font-size:30px; 
        color: #d9d9d9; 
        font-weight: bold;
        text-shadow: 0 0 6px #999;
        text-align: center;      
      }
      .pair { 
        display: inline-block; 
        width: 88px;
        margin: 10px 10px 0;
        padding: 5px 0 5px 10px;
        border: 1px solid transparent;
      }
      .pair.active {
        background: rgba(255,255,0,.25);
        border: 1px solid rgba(255,255,0,.5);
      }
      .pair.complete {
        opacity: .25;
      }
      .pair .organism { 
        display: inline-block; width: 34px; margin-right: 10px;
      }
      .pair canvas { width:34px; border: 1px solid #b3b3b3; }
      .round-index { font-family: 'Helvetica'; font-size:60px; color: #d9d9d9; font-weight: bold;
                     text-shadow: 0 0 4px #999; position: absolute; left: 0; top: 0; }

      .round4 .pair { width:172px;  margin-left: 20px; }
      .round4 .organism { width:68px; }
      .round4 canvas { width:68px; }

      .round5 .pair { width:220px;  margin-left: 40px; }
      .round5 .organism { width:100px; }
      .round5 canvas { width:100px; }

      .round6 .pair { width:220px;  margin-left: 40px; }
      .round6 .organism { width:100px; }
      .round6 canvas { width:100px; }

  </style>
  <script type="text/javascript" src="Box2dWeb-2_1_a_3.js" charset="utf-8"></script>
  <script type="text/javascript" src="deathmatch-creature-v1.js" charset="utf-8"></script>
  <script type="text/javascript" src="deathmatch-v1.js" charset="utf-8"></script>
  <script type="text/javascript" src="deathmatch-render-v1.js" charset="utf-8"></script>
  <script language="javascript">

  var POPULATION_SIZE = 64;
  var SPECIES_SIZE = 16;
  var match, pairs, runInterval, roundSize, population, roundIndex, matchIndex, generationIndex = 1;
  var matchTimeout, simulation, generation, round;
  var accelerated = false;
  var state = 'PRE_TOURNAMENT';

  function el(id) { return document.getElementById(id); }
  function gen( name, clss, atts ) {
    var el = document.createElement(name), out={};
    if ( typeof clss == 'object' ) atts=clss, clss=null;
    for (var att in atts) el.setAttribute(att,atts[att]);
    if ( clss ) el.setAttribute('class', clss);
    out.add = function(node) { return el.appendChild( node.el ? node.el() : node ), out; };
    out.text = function(txt) { return el.appendChild( document.createTextNode(txt) ), out };
    out.el = function() { return el; };
    return out;
  }

  /* url (string*), body (string), handler (string->), errorHandler (number->), headers ({:string}) */
  function request( options ) {
    var xhr =  window.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") : new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if ( xhr.readyState < 4 ) return;
      if ((!xhr.status && (location.protocol == "file:")) || (xhr.status >= 200 && xhr.status < 300) 
          || xhr.status == 304 || xhr.status == 1223) {
        if (options.handler) options.handler(xhr.responseText);
      } else if (options.errorHandler) options.errorHandler(xhr.status)
    };
    xhr.open(options.method || 'GET', options.url, true );
    if (options.headers) for (var k in options.headers) xhr.setRequestHeader(k, options.headers[k]);
    if (("POST" === options.method) && (( ! options.headers ) || ( ! options.headers['Content-Type'] )))
      xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
    xhr.send( options.body || null );
  }

  function parseCFG( parser, text ) {
    var state = parser.rules[parser.initial_state], lines = text.split(/\r?\n/), ctx={};
    if ( parser.initialize ) parser.initialize(ctx);
    for (var i=0,line; line=lines[i], i<lines.length; i++)
      if (match = line.match(state[0]))
        for (var j=0; j<match.length; j++)
          if (match[j] != null && state[1][j]) {
            state = parser.rules[ state[1][j](match, ctx) ]
            break;
          }
    return ctx;
  }

  var multipartJSONParser = {
    initial_state: 'PREAMBLE',
    initialize: function(ctx) { ctx.content = []; },
    rules: {
      PREAMBLE : [ /^--(.*[^-].|.*[^-])$/, {
        1:function(m, ctx) { ctx.boundary = m[1]; return 'HEADERS'; }}],
      HEADERS : [ /(^$)|^Content-type:\s*(.*?)(;.*)?$/i, {
        1:function(m, ctx) { ctx.chunk = []; return 'CONTENT'; },
        2:function(m, ctx) { 
          if (m[2] == 'multipart/mixed') return 'PREAMBLE';
          ctx.skip = (m[2] != 'application/json'); return 'HEADERS'; }}],
      CONTENT : [ /^--(.*?)--?$|^--(.*)$|^(.*)$/, {
        1:function(m, ctx) {
          if ( m[1] != ctx.boundary ) { ctx.chunk.push(m[0]); return 'CONTENT' }
          if (!ctx.skip) ctx.content.push(JSON.parse(ctx.chunk.join('\n')));
          return 'PREAMBLE'; },
        2:function(m, ctx) {
          if (!ctx.skip && ctx.chunk.length) 
            ctx.content.push(JSON.parse(ctx.chunk.join('\n')));
          ctx.boundary = m[2];
          return 'HEADERS'; },
        3:function(m, ctx) {ctx.chunk.push(m[0]); return 'CONTENT'; }}]
    }
  }

  function multipart_json(body) {
    return parseCFG( multipartJSONParser, body ).content;
  }

  function saveGeneration() {
    var key = encodeURIComponent(simulation)+'-'+lpad(7,generationIndex);
    request({
      method:'PUT',
      url:'/riak/generations/'+key,
      headers: {
        'Content-type':'application/json',
        'x-riak-index-simulation_bin':simulation,
        'x-riak-index-generation_int':generationIndex+''
      },
      body: JSON.stringify(generation)
    });
    request({
      method:'PUT',
      url:'/riak/checkpoints/'+encodeURIComponent(simulation),
      headers: {
        'Content-type':'application/json',
        Link: '</riak/generations/'+key+'>; riaktag="latest"'
      },
      body: JSON.stringify({index:generationIndex})
    })
  }

  function shuffle(ar) {
    for (var i=0, l=ar.length,t,dx; i<l; i++) { dx=(Math.random()*l)|0; t=ar[dx]; ar[dx]=ar[i]; ar[i]=t; } 
  }

  function lpad(n,d) { return String(Math.pow(10,n) + d).substring(1); }

  function initializeTournament() {
    population = [];
    while ( population.length < POPULATION_SIZE )
      population = population.concat( deathmatch.creature.newSpecies( Math.min(SPECIES_SIZE, POPULATION_SIZE-population.length) ) );
    for ( var i=0, organism; organism = population[i]; i++ )
      organism.index = i;
    startTournament();
  }

  function startTournament() {
    generation = {population:population, rounds:[]}
    round = [];

    // initialize stats
    for ( var i=0, l=population.length; i<l; i++ ) {
      population[i].wins = 0;
      population[i].score = 0;
    }
    
    shuffle( population );
    roundSize = POPULATION_SIZE/2;
    pairs = deathmatch.contest.pairOpponents( population, roundSize );

    roundIndex = 1;
    matchIndex = 0;
    var header = 'generation ' + generationIndex;
    if (simulation) header = simulation + ' - ' + header;
    el('generation').innerHTML = header;
    el('rounds').innerHTML = '';
    renderRound( roundIndex, pairs );
    nextMatch();
  }

  function nextGeneration() {
    population = deathmatch.contest.nextGeneration(generation);
    generationIndex++;
    startTournament();
  }

  function nextRound() {
    round = [];

    if ( roundSize < 2 ) {
      if ( simulation && simulation.length )
        saveGeneration()

      return nextGeneration();
    }

    roundSize /= 2;

    population.sort( deathmatch.contest.compareOpponents );
    pairs = deathmatch.contest.pairOpponents( population, roundSize );

    roundIndex++;
    matchIndex = 0;
    renderRound( roundIndex, pairs );

    nextMatch();
  }

  function renderRound( roundIndex, pairs ) {
    var rounds = el('rounds');
    var round = gen('div', 'round round'+roundIndex).add(gen('span','round-index').text(7-roundIndex));
    for ( var i=0,pair; pair = pairs[i]; i++ )
      round.add( gen('div', 'pair', {id:'pair-'+roundIndex+'-'+i} ).add(
        gen('div','organism',{id:'org-'+roundIndex+'-'+i+'-0'})
          .add( gen('canvas', {id:'cvs-'+roundIndex+'-'+i+'-0', width:200, height:200 }))
          .add( gen('div','stats', {id:'stats-'+roundIndex+'-'+i+'-0'}) )
      ).add(
        gen('div','organism',{id:'org-'+roundIndex+'-'+i+'-1'})
          .add( gen('canvas', {id:'cvs-'+roundIndex+'-'+i+'-1', width:200, height:200 }))
          .add( gen('div','stats', {id:'stats-'+roundIndex+'-'+i+'-1'}) )
      ) );


    if ( rounds.firstChild )
      rounds.insertBefore( round.el(), rounds.firstChild );
    else
      rounds.appendChild( round.el() );

    for ( var i=0,pair; pair = pairs[i]; i++ ) {
      var cvs = el('cvs-'+roundIndex+'-'+i+'-0');
      cvs.setAttribute('height', cvs.offsetHeight * 2);
      cvs.setAttribute('width', cvs.offsetWidth * 2);
      renderCreature(cvs.getContext('2d'), pair[0].genome )
      cvs = el('cvs-'+roundIndex+'-'+i+'-1');
      cvs.setAttribute('height', cvs.offsetHeight * 2);
      cvs.setAttribute('width', cvs.offsetWidth * 2);
      renderCreature(cvs.getContext('2d'), pair[1].genome )
    }

  }

  function renderCreature( ctx, genome ) {
    var s = deathmatch.contest.PIXELS_PER_METER;
    var transform = new deathmatch.creature.T().translate( ctx.canvas.width*s/2, ctx.canvas.width*s/2 );
    var creature = deathmatch.creature.generate( genome, transform, true, s );

    ctx.save();
    ctx.fillStyle = 'rgba(0,80,120,.2)';
    ctx.lineWidth = 20;
    ctx.strokeStyle = 'rgba(0,0,0,.8)';
    deathmatch.render.renderToFit( creature, ctx );     
    ctx.restore();      
  }

  function nextMatch() {
    el('pair-'+roundIndex+'-'+matchIndex).setAttribute('class','pair active');
    var pair = pairs.splice(0,1)[0];
    match = deathmatch.contest.startMatch( pair[0], pair[1] );
    if ( match.result ) // immediate disqualification
      return matchComplete();

    state = 'IN_MATCH';
    play();
  }

  function play() {
    if ( state == 'IN_MATCH' ) {
      runInterval = setInterval(function(){
        updateMatch();
      }, accelerated ? 1 : 1000/60 );
    } else if ( state == 'PRE_ROUND' ) {
      nextRound();
    } else if ( state == 'PRE_MATCH' ) {
      nextMatch();
    }
  }

  function updateMatch() {
    if ( ! deathmatch.contest.updateMatch( match ) ) {
      clearInterval(runInterval);
      runInterval = null;
      matchComplete();
    }

    if ( ! accelerated ) {
      var ctx = el('display').getContext('2d');

      ctx.fillStyle = 'rgba(52,82,122,.4)';
      ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);

      deathmatch.render.renderCanvas(ctx, match);
    }
  }

  function matchComplete() {
    round.push( deathmatch.contest.matchSummary(match) );

    var ctx = el('display').getContext('2d');
    
    if ( accelerated ) {
      ctx.fillStyle = 'rgba(52,82,122,1)';
      ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);

      deathmatch.render.renderCanvas(ctx, match);
    } else if ( match.iterations == 0 ) {
      ctx.fillStyle = 'rgba(52,82,122,1)';
      ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);

      deathmatch.render.renderCanvas(ctx, match);
    }

    el('pair-'+roundIndex+'-'+matchIndex).setAttribute('class','pair complete');
    var ctx = el('display').getContext('2d');
    ctx.font = 'bold 50px Helvetica';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255,255,255,1)';
    ctx.fillText(match.result, 400, 200);
    if ( ! pairs.length ) {
      generation.rounds.push(round);
      state = 'PRE_ROUND';
      return matchTimeout = setTimeout( nextRound, accelerated ? 1 : 1000 );
    }

    matchIndex++;
    state = 'PRE_MATCH';
    matchTimeout = setTimeout( nextMatch, accelerated ? 1 : 1000 );
  }

  function startSimulation() {
    el('startup').style.display = 'none';
    el('simulation').style.display = 'block';

    simulation = el('simulation_name').value.match(/^\s*(.*?)\s*$/)[1];

    if ( simulation ) {
      request({url:'/riak/checkpoints/'+encodeURIComponent(simulation)+'/_,latest,_/', 
        handler: function(o) { 
          generationIndex = o.match(/^x-riak-index-generation_bin: (\d+)/m)[1]|0;
          generation = multipart_json(o)[0];
          population = generation.population;
          nextGeneration();
        }, 
        errorHandler:function(o) { 
          initializeTournament();
        } });
    } else {
      initializeTournament();
    }

    document.onkeypress = function(e) { 
      if (e.keyCode == 32) {
        accelerated = !accelerated;
        clearInterval(runInterval);
        clearTimeout(matchTimeout);
        runInterval = null;
        matchTimeout = null;
        play();
        return false;
      }
    }
  }

  function init() {
    el('continue').onclick = startSimulation;
    el('simulation_name').onkeyup = function() {
      el('continue').innerHTML = el('simulation_name').value.match(/\S/) ? 'begin' : 'skip';
    }
    el('simulation_name').focus();
  }

  </script>
</head>
<body onload="init()">
  <div id="startup">
    <div class="name">
      <label>simulation name:</label>
      <input type="text" id="simulation_name"/>
      <button id="continue">skip</button>
    </div>
  </div>
  <div id="simulation">
    <h1 id="generation"></h1>
    <canvas id="display" width="800" height="500"></canvas>
    <div id="rounds"></div>
  </div>
</body>
</html>
